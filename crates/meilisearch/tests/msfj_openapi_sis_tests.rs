use utoipa::OpenApi;

// This test verifies that the OpenAPI specification generated by Meilisearch
// correctly includes the paths and schemas related to the single-index snapshot feature.
#[test]
fn test_fj_snapshot_openapi_paths_and_schemas() {
    // Generate the OpenAPI specification
    let openapi = meilisearch::routes::MeilisearchApi::openapi();

    // --- Verify the '/indexes/{indexUid}/snapshots' path (POST for creation) ---
    let create_snapshot_path = "/indexes/{indexUid}/snapshots";
    let path_item_create = openapi
        .paths
        .paths
        .get(create_snapshot_path)
        .unwrap_or_else(|| panic!("OpenAPI spec is missing path: {}", create_snapshot_path));

    assert!(
        path_item_create.post.is_some(),
        "Path {} is missing the POST operation for snapshot creation.",
        create_snapshot_path
    );
    // Optionally, further inspect path_item_create.post.unwrap().summary, .tags, .parameters, .responses etc.
    // For example, check if it's tagged under "Indexes"
    let post_op_create = path_item_create.post.as_ref().unwrap();
    assert!(
        post_op_create.tags.as_ref().map_or(false, |tags| tags.contains(&"Indexes".to_string())),
        "POST {} operation is not tagged under 'Indexes'",
        create_snapshot_path
    );

    // --- Verify the '/snapshots/import' path (POST for import) ---
    let import_snapshot_path = "/snapshots/import";
    let path_item_import = openapi
        .paths
        .paths
        .get(import_snapshot_path)
        .unwrap_or_else(|| panic!("OpenAPI spec is missing path: {}", import_snapshot_path));

    assert!(
        path_item_import.post.is_some(),
        "Path {} is missing the POST operation for snapshot import.",
        import_snapshot_path
    );
    // Optionally, further inspect path_item_import.post.unwrap().request_body, .responses etc.
    let post_op_import = path_item_import.post.as_ref().unwrap();
    assert!(
        post_op_import.tags.as_ref().map_or(false, |tags| tags.contains(&"Snapshots".to_string())),
        "POST {} operation is not tagged under 'Snapshots'",
        import_snapshot_path
    );

    // --- Verify the 'FjSingleIndexSnapshotImportPayload' schema ---
    let components = openapi
        .components
        .as_ref()
        .expect("OpenAPI spec is missing components section.");

    // Use schema() as suggested by compiler, and literal keys for map lookup
    // let _schema_fj = FjSingleIndexSnapshotImportPayload::schema(); // Call to check if it compiles - Removed as unused
    let schema_key_fj_literal = "FjSingleIndexSnapshotImportPayload";
    // println!("DEBUG: Attempting to check presence of schema for FjSingleIndexSnapshotImportPayload using key: '{}'", schema_key_fj_literal); // Removed for cleaner output
    assert!(
        components.schemas.contains_key(schema_key_fj_literal),
        "OpenAPI spec components are missing schema: {}",
        schema_key_fj_literal
    );

    let schema_ref_or_fj = components.schemas.get(schema_key_fj_literal).unwrap_or_else(|| {
        panic!("Failed to get schema for key: {}", schema_key_fj_literal)
    });
    match schema_ref_or_fj {
        utoipa::openapi::RefOr::T(schema_object) => { 
            // Serialize the schema object to JSON to inspect its structure at runtime,
            // as direct field access seems problematic in the test context.
            let schema_json = serde_json::to_value(&schema_object).expect("Failed to serialize schema object to JSON");
            
            // Assert against the JSON structure
            assert_eq!(
                schema_json.get("type").and_then(|v| v.as_str()),
                Some("object"),
                "Schema type should be 'object'."
            );

            let required_fields = schema_json.get("required").and_then(|v| v.as_array()).expect("Schema should have a 'required' array.");
            let required_set: std::collections::HashSet<&str> = required_fields.iter()
                .filter_map(|v| v.as_str())
                .collect();
                
            assert!(required_set.contains("sourceSnapshotFilename"), "sourceSnapshotFilename should be required.");
            assert!(required_set.contains("targetIndexUid"), "targetIndexUid should be required.");

            let properties = schema_json.get("properties").and_then(|v| v.as_object()).expect("Schema should have a 'properties' object.");
            assert!(properties.contains_key("sourceSnapshotFilename"), "Schema properties should include 'sourceSnapshotFilename'.");
            assert!(properties.contains_key("targetIndexUid"), "Schema properties should include 'targetIndexUid'.");
            
            // Optionally, check property types
            assert_eq!(
                properties.get("sourceSnapshotFilename").and_then(|p| p.get("type")).and_then(|t| t.as_str()),
                Some("string"),
                "sourceSnapshotFilename property type should be string."
            );
             assert_eq!(
                properties.get("targetIndexUid").and_then(|p| p.get("type")).and_then(|t| t.as_str()),
                Some("string"),
                "targetIndexUid property type should be string."
            );
        }
        utoipa::openapi::RefOr::Ref(_) => {
            panic!("Schema {} is a reference, expected an inline object schema for this test.", schema_key_fj_literal);
        }
    }

    // --- Verify 'SummarizedTaskView' schema (as it's a common response) ---
    let schema_key_task_literal = "SummarizedTaskView";
    assert!(
        components.schemas.contains_key(schema_key_task_literal),
        "OpenAPI spec components are missing schema: {}",
        schema_key_task_literal
    );
    // Detailed introspection for SummarizedTaskView is omitted as it's not the focus here.

    // --- Verify 'IndexUid' schema ---
    // Verification omitted as IndexUid is typically represented as a string parameter
    // in path definitions and might not appear as a separate schema component.
}
